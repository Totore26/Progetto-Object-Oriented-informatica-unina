\section{Triggers}


In questa sezione verranno mostrati tutti i triggers implementati per ottenere un database \textbf{consistente} e che continua a funzionare nel tempo, assicurando di avere dei \textbf{dati concreti e attendibili}. \\

\subsection{Triggers su Impiegato}
    \begin{itemize}
    
\item Il trigger \textbf{insert\_storico} si occupa di controllare se all'inserimento di un impiegato la data\_assunzione è coerente con l'attributo tipo\_impiegato, nel caso affermativo calcola e inserisce tutti gli scatti di carriera fatti.
\scriptsize %dimensione del testo 
\begin{lstlisting}
CREATE OR REPLACE TRIGGER insert_storico
AFTER INSERT ON impiegato
FOR EACH ROW
EXECUTE FUNCTION f_insert_storico();

CREATE OR REPLACE FUNCTION f_insert_storico() RETURNS TRIGGER AS
$$
BEGIN
    IF (NEW.tipo_impiegato = 'junior') THEN
        IF((NEW.data_assunzione + INTERVAL '3 years') >= CURRENT_DATE ) THEN
            INSERT INTO storico VALUES (NULL, 'junior', NEW.data_assunzione, NEW.matricola);
        ELSE
            RAISE EXCEPTION 'DATA DI ASSUNZIONE NON VALIDA PER UN DIPENDENTE JUNIOR';
        END IF;
    
    ELSIF (NEW.tipo_impiegato = 'middle') THEN
        IF ((NEW.data_assunzione + INTERVAL '3 years') <= CURRENT_DATE AND
            NEW.data_assunzione + INTERVAL '7 years' >= CURRENT_DATE ) THEN
                INSERT INTO storico VALUES (NULL, 'junior', NEW.data_assunzione, NEW.matricola);
                INSERT INTO storico VALUES ('junior', 'middle', NEW.data_assunzione + INTERVAL '3 years', NEW.matricola);
        ELSE
            RAISE EXCEPTION 'DATA DI ASSUNZIONE NON VALIDA PER UN DIPENDENTE MIDDLE';
        END IF;
    
    ELSIF (NEW.tipo_impiegato = 'senior') THEN
        IF((NEW.data_assunzione + INTERVAL '7 years') <= CURRENT_DATE ) THEN
            INSERT INTO storico VALUES (NULL, 'junior', NEW.data_assunzione, NEW.matricola);
            INSERT INTO storico VALUES ('junior', 'middle', NEW.data_assunzione + INTERVAL '3 years', NEW.matricola);
            INSERT INTO storico VALUES ('middle', 'senior', NEW.data_assunzione + INTERVAL '7 years', NEW.matricola);
        ELSE
            -- Error message
            RAISE EXCEPTION 'DATA DI ASSUNZIONE NON VALIDA PER UN DIPENDENTE SENIOR';
        END IF;	
    END IF;
    
    IF(new.dirigente is true) THEN
            INSERT INTO STORICO VALUES('NonDirigente','dirigente', CURRENT_DATE, new.matricola);
        END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
\end{lstlisting}

\normalsize
\item Il trigger \textbf{update\_dirigente} si occupa di inserire il nuovo scatto di carriera all'interno dello storico; Nel caso in cui si declassa un dirigente si verifica se è responsabile di qualche progetto attivo, nel caso affermativo lancia il messaggio di errore.

\scriptsize
\begin{lstlisting}
CREATE OR REPLACE TRIGGER update_dirigente
AFTER UPDATE OF dirigente On impiegato
FOR EACH ROW
EXECUTE FUNCTION f_update_dirigente();

CREATE OR REPLACE FUNCTION f_update_dirigente() RETURNS trigger AS
$$
BEGIN
	IF((OLD.dirigente = false ) AND NEW.dirigente = true)THEN
		INSERT INTO STORICO VALUES('NonDirigente','dirigente', CURRENT_DATE, new.matricola);

	ELSIF (NEW.dirigente = false AND OLD.dirigente = true)THEN
		IF EXISTS(SELECT* FROM PROGETTO WHERE responsabile = new.matricola AND (data_fine is null or data_fine > CURRENT_DATE) ) THEN

			RAISE EXCEPTION 'NON PUOI DECLASSARE UN DIRIGENTE SE GESTISCE UN PROGETTO, BISOGNA PRIMA CAMBIARLO!';


		ELSE
			INSERT INTO STORICO VALUES('dirigente','NonDirigente', CURRENT_DATE, new.matricola);
		END IF;

	END IF;

	RETURN NEW;

END;
$$ language plpgsql;
\end{lstlisting}
\newpage
\normalsize
\item Il trigger \textbf{not\_update\_tipo\_impiegato} scatta alla modifica degli attributi tipo\_impiegato e data\_assunzione ne blocca la modifica, in modo da rendere consistente la base di dati.
\scriptsize
\begin{lstlisting}
CREATE OR REPLACE TRIGGER  not_update_tipo_impiegato
AFTER UPDATE OF tipo_impiegato,data_assunzione ON impiegato
FOR EACH ROW
EXECUTE FUNCTION f_not_update_tipo_impiegato();

CREATE OR REPLACE FUNCTION f_not_update_tipo_impiegato() RETURNS TRIGGER AS
$$
BEGIN
	RAISE EXCEPTION 'UNA VOLTA INSERITO UN IMPIEGATO NON PUOI MODIFICARE IL SUO TIPO O LA DATA DI ASSUNZIONE.';
	RETURN NEW;
END;
$$ LANGUAGE plpgsql;
\end{lstlisting}

\normalsize
\item Il trigger \textbf{eliminazione\_impiegati\_speciali} impedisce l'eliminazione di impiegati attuali che sono referenti o responsabili di un progetto/laboratorio, inviando un messaggio di errore.
\scriptsize
\begin{lstlisting}
CREATE OR REPLACE TRIGGER eliminazione_impiegati_speciali
BEFORE DELETE ON IMPIEGATO
FOR EACH ROW
EXECUTE function f_eliminazione_impiegati_speciali();

CREATE OR REPLACE FUNCTION f_eliminazione_impiegati_speciali() RETURNS TRIGGER AS
$$
BEGIN
	IF EXISTS(select* from PROGETTI_ATTUALI where responsabile = NEW.matricola) THEN

    	RAISE EXCEPTION 'IMPOSSIBILE ELIMINARE IL RESPONSABILE DI UN PROGETTO ATTIVO, PRIMA BISOGNA SOSTITUIRLO!';
	END IF;

	IF EXISTS(select* from PROGETTI_ATTUALI where referente = NEW.matricola) THEN

    	RAISE EXCEPTION 'IMPOSSIBILE ELIMINARE IL REFERENTE DI UN PROGETTO ATTIVO, PRIMA BISOGNA SOSTITUIRLO!';
	END IF;

	IF EXISTS(select* from LABORATORIO where r_scientifico = NEW.matricola) THEN
    	RAISE EXCEPTION 'IMPOSSIBILE ELIMINARE IL RESPONSABILE SCIENTIFICO DI UN LABORATORIO, PRIMA BISOGNA SOSTITUIRLO!';
	END IF;
	RETURN OLD;
END;
$$ language plpgsql;
\end{lstlisting}

\newpage    
\normalsize
\item Il seguente trigger \textbf{check\_stipendio} controlla la gerarchia degli stipendi ricevuti per ogni impiegato, verificando che un Junior riceve meno di un Middle che a sua volta riceve meno di un Senior. Da tale vincolo di integrità sematica fa eccezione il Dirigente.
\scriptsize
\begin{lstlisting}
CREATE OR REPLACE TRIGGER check_stipendio
AFTER INSERT OR UPDATE OF stipendio ON Impiegato
FOR EACH ROW
execute function f_check_stipendio();

CREATE OR REPLACE FUNCTION f_check_stipendio() RETURNS TRIGGER AS
$$
BEGIN
	IF(NEW.dirigente is true)then
		RETURN NEW;
	END IF;

	IF(new.tipo_impiegato = 'junior' AND EXISTS(select* from Impiegato as i where i.tipo_impiegato <> 'junior' and i.stipendio < new.stipendio )) then

		RAISE EXCEPTION 'UN IMPIEGATO JUNIOR NON PUO AVERE LO STIPENDIO PIU ALTO DI UN MIDDLE';
	
	ELSIF(new.tipo_impiegato = 'middle' AND EXISTS(select* from Impiegato as i where i.tipo_impiegato ='senior' and i.stipendio < new.stipendio)) then

		RAISE EXCEPTION 'UN IMPIEGATO MIDDLE NON PUO AVERE LO STIPENDIO PIU ALTO DI UN SENIOR';
	END IF;

	RETURN NEW;
END;
$$ LANGUAGE plpgsql;
\end{lstlisting}

\newpage
\normalsize
\item Il seguente trigger \textbf{avviso\_su\_impiegati\_licenziati} parte nel caso in cui licenzio un impiegato; Se esso è un responsabile di un progetto o di un laboratorio o, nel caso in cui sia un referente, manda il messaggio di warning avvisando l'utente di aggiornare gli eventuali errori.

\scriptsize
\begin{lstlisting}
CREATE OR REPLACE TRIGGER avviso_su_impiegati_licenziati
AFTER UPDATE OF data_licenziamento ON impiegato
FOR EACH ROW
EXECUTE FUNCTION f_avviso_su_impiegati_licenziati();

CREATE OR REPLACE FUNCTION f_avviso_su_impiegati_licenziati() RETURNS TRIGGER AS
$$
DECLARE
	impiegato RECORD;
BEGIN
	IF NEW.data_licenziamento IS NOT NULL THEN

		SELECT l.r_scientifico, l.id_lab INTO impiegato
		FROM laboratorio AS l
		WHERE NEW.matricola = l.r_scientifico
		AND l.r_scientifico NOT IN (select matricola from Impiegati_attuali);

		IF FOUND THEN
			RAISE WARNING 'L IMPIEGATO CON MATRICOLA % E STATO LICENZIATO, AGGIORNA IL REFERENTE SCIENTIFICO NEL LABORATORIO %', NEW.matricola, impiegato.id_lab;
		END IF;

		SELECT pa.referente, pa.cup INTO impiegato
		FROM PROGETTI_ATTUALI as pa
		WHERE NEW.matricola = pa.referente
		AND pa.referente NOT IN (select matricola from Impiegati_attuali);

		IF FOUND THEN
			RAISE WARNING 'L IMPIEGATO CON MATRICOLA % E STATO LICENZIATO, AGGIORNA IL REFERENTE NEL PROGETTO %', NEW.matricola, impiegato.cup;
		END IF;

		SELECT pa.responsabile, pa.cup INTO impiegato
		FROM PROGETTI_ATTUALI as pa
		WHERE NEW.matricola = pa.responsabile
		AND pa.responsabile NOT IN (select matricola from Impiegati_attuali);

		IF FOUND THEN
			RAISE WARNING 'L IMPIEGATO CON MATRICOLA % E STATO LICENZIATO, AGGIORNA IL RESPONSABILE NEL PROGETTO %', NEW.matricola, impiegato.cup;
		END IF;

	END IF;

	RETURN NEW;
END; $$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER trigger_avviso_su_impiegati_licenziati
AFTER UPDATE OF data_licenziamento ON impiegato
FOR EACH ROW
EXECUTE FUNCTION f_avviso_su_impiegati_licenziati();
\end{lstlisting}


\end{itemize}
\newpage

\subsection{Triggers su Laboratorio}
    \begin{itemize}

  
\normalsize
\item Il trigger \textbf{check\_responsabile\_scientifico} verifica in caso di inserimento o modifica del responsabile di un laboratorio che sia un senior come specificato da traccia, altrimenti ne impedisce l'inserimento o la modifica.
\scriptsize
\begin{lstlisting}
CREATE OR REPLACE TRIGGER check_responsabile_scientifico
BEFORE INSERT OR UPDATE OF r_scientifico ON laboratorio
FOR EACH ROW
EXECUTE FUNCTION check_responsabile_scientifico();

CREATE OR REPLACE FUNCTION f_check_responsabile_scientifico() RETURNS TRIGGER AS
$$
BEGIN
	IF NEW.r_scientifico NOT IN (select matricola from Impiegati_attuali where tipo_impiegato = 'senior') THEN
		RAISE EXCEPTION 'IL REFERENTE SCIENTIFICO DEVE ESSERE UN SENIOR ATTUALE DELL AZIENDA!';
	END IF;

	RETURN NEW;
END;
$$ LANGUAGE plpgsql;
\end{lstlisting}

\end{itemize}
\newpage




\subsection{Triggers su Afferenza}
\begin{itemize}
    
\normalsize
\item Il trigger \textbf{check\_afferenza} verifica nel caso in cui voglio far afferire un impiegato ad un dato laboratorio inanzitutto che non sia licenziato, dopodichè controlla che l'ammontare delle ore lavorative al giorno siano minori di 8 ore.
\scriptsize
\begin{lstlisting}
CREATE OR REPLACE TRIGGER check_afferenza
AFTER INSERT OR UPDATE OF ore_giornaliere ON AFFERENZA
FOR EACH ROW
EXECUTE FUNCTION f_check_afferenza();

CREATE OR REPLACE FUNCTION f_check_afferenza() RETURNS TRIGGER AS
$$
BEGIN
	IF(new.matricola not in(select matricola from Impiegati_attuali)) THEN
		RAISE EXCEPTION 'NON PUOI FAR AFFERIRE AD UN LABORATORIO UN IMPIEGATO LICENZIATO';
	END IF;
	
	IF (new.ore_giornaliere > 8) THEN
		RAISE EXCEPTION 'UN IMPIEGATO NON PUO LAVORARE PER PIU DI OTTO ORE AL GIORNO!';
	END IF;
	RETURN NEW;
END;
$$ LANGUAGE plpgsql;
\end{lstlisting}

\normalsize
\item I seguenti trigger \textbf{inserisci\_afferenti, cancella\_afferenti} scattano all'inserimento o cancellazione di una o più tuple in afferenza, si occupano di aggiornare l'attributo numero\_afferenti nella tabella laboratorio.
\scriptsize
\begin{lstlisting}
CREATE OR REPLACE TRIGGER inserisci_afferenti
AFTER INSERT ON AFFERENZA
FOR EACH ROW
EXECUTE FUNCTION f_inserisci_afferenti();

CREATE OR REPLACE TRIGGER cancella_afferenti
AFTER DELETE ON AFFERENZA
FOR EACH ROW
EXECUTE FUNCTION f_cancella_afferenti();

CREATE OR REPLACE FUNCTION f_inserisci_afferenti() RETURNS trigger AS 
$$
BEGIN
	UPDATE laboratorio
	SET numero_afferenti = numero_afferenti + 1
	WHERE id_lab = new.id_lab;
RETURN NEW;
END;
$$ Language plpgsql;

CREATE OR REPLACE FUNCTION f_cancella_afferenti() RETURNS trigger AS
$$
BEGIN
	UPDATE laboratorio
	SET numero_afferenti = numero_afferenti - 1
	WHERE id_lab = old.id_lab;
RETURN NEW;
END; $$ LANGUAGE plpgsql;
\end{lstlisting}


\end{itemize}
\newpage




\subsection{Triggers su Progetto}
    \begin{itemize}
    
\normalsize
\item Questo trigger \textbf{check\_update\_dirigente\_or\_responsabile} scatta all'inserimento o modifica di una o più tuple nella tabella progetto, si occupa di verificare che il referente sia un dirigente e che il responsabile sia un senior, altrimenti blocca l'inserimento e manda un messaggio di errore.
\scriptsize
\begin{lstlisting}
CREATE OR REPLACE TRIGGER check_update_dirigente_or_responsabile
AFTER INSERT OR UPDATE OF referente, responsabile ON PROGETTO
FOR EACH ROW
EXECUTE FUNCTION f_check_referente_or_dirigente();

CREATE OR REPLACE FUNCTION f_check_referente_or_dirigente() RETURNS TRIGGER AS
$$
BEGIN
	IF(new.responsabile not in (select matricola from Dirigenti_Attuali)) THEN
		RAISE EXCEPTION 'IL RESPONSABILE DEVE ESSERE UN DIRIGENTE NON LICENZIATO!';
	END IF;
	IF(new.referente not in (select matricola from Impiegati_attuali where tipo_impiegato = 'senior'))THEN
		RAISE EXCEPTION 'IL REFERENTE DEVE ESSERE UN IMPIEGATO SENIOR NON LICENZIATO!';
	END IF;
RETURN NEW;
END;
$$ language plpgsql;
\end{lstlisting}
 
\end{itemize}
\newpage




\subsection{Triggers su Gestione}
    \begin{itemize}
    
\normalsize
\item Il trigger \textbf{max\_labs\_per\_cup} scatta all'inserimento di una o più tuple in gestione, si occupa di rispettare il vincolo imposto dalla traccia dove viene specificato che un progetto attivo ha al più tre laboratori associati.
\scriptsize
\begin{lstlisting}
CREATE OR REPLACE TRIGGER max_labs_per_cup
BEFORE INSERT ON GESTIONE
FOR EACH ROW
EXECUTE FUNCTION f_max_labs_per_cup();

CREATE OR REPLACE FUNCTION f_max_labs_per_cup() RETURNS TRIGGER AS
$$
DECLARE
    lab_count INTEGER;
BEGIN
	IF(new.cup in (select cup from PROGETTI_TERMINATI)) then
		RAISE EXCEPTION 'NON PUOI ASSOCIARE UN PROGETTO TERMINATO AD UN LABORATORIO';
	END IF;

    SELECT COUNT(*) INTO lab_count FROM Gestione_Attuale WHERE cup = NEW.cup;
    IF lab_count > 3 THEN
        RAISE EXCEPTION 'NON E POSSIBILE ASSOCIARE PIU DI TRE ID_LAB AD UN CUP (CODICE PROGETTO)';
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

\end{lstlisting}
 
\end{itemize}
\newpage





